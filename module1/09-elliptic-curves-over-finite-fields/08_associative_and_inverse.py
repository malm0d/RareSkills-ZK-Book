from py_ecc.bn128 import G1, eq, multiply, add, neg, is_inf, Z1

# *** Associativity ***
# Recall in group theory that groups are associative.
# Thus we expect the following to be true:
x = 2 ** 222
y = 99 ** 7
z = 15

# (xG + yG) + zG
lhs = add(add(multiply(G1, x), multiply(G1, y)), multiply(G1, z))
# xG + (yG + zG)
rhs = add(multiply(G1, x), add(multiply(G1, y), multiply(G1, z)))
# (xG + yG) + zG == xG + (yG + zG)
assert eq(lhs, rhs)

# *** Inverse of Finite Field Elements ***
# In a finite field, every NON-ZERO element has a multiplicative inverse. By definition, 0 has no 
# multiplicative inverse in any field. Every element in a finite field has an additive inverse,
# including 0, which is its own additive inverse. That is, a finite field has two group structures:
# (F, +) and (F, x), and so by definition, it would have two different identities: 
# 0 (the additive identity) and 1 (the multiplicative identity).
# In a finite field, any element added to its additive inverse yields the additive identity 0, while all
# non-zero elements when multiplied by its multiplicative inverse, yields the multiplicative identity 1.
#
# *** In ellipic curves over finite fields, EVERY element has an inverse ***
# The py_ecc library supplies us with the `neg`` function which will provide the inverse of a given element by
# flipping it over the y-axis (in a finite field). The library encodes the “point at infinity” as a Python `None`.
# 
# Pick a field element
x = 1234567890987654321
# Generate the point
p = multiply(G1, x)
# Get the inverse of p
p_inv = neg(p)
# Every element added to its inverse produces the identity element, that is, in ellipic curves over finite fields,
# adding an element with its additive inverse will yield the "point at infinity". However, this is only true
# for an elliptic curve group over a finite field (not to be confused with just finite fields).
assert is_inf(add(p, p_inv))
# Z1 is just None, which is the "point at infinity"
assert Z1 is None
# special case: the inverse of the identity is itself
assert eq(neg(Z1), Z1)

# As is the case with elliptic curves over real numbers, with elliptic curves over finite fields, the inverse
# of an elliptic curve point has the same x value, but the y value is the inverse.
field_modulus = 21888242871839275222246405745257275088696311157297823662689037894645226208583
for i in range(1, 4):
    point = multiply(G1, i)
    print(point)
    print(neg(point))
    print('----')

    # x values are the same
    assert int(point[0]) == int(neg(point)[0])

    # y values are inverses of each other, we are adding y values
    # not elliptic curve points
    assert int(point[1]) + int(neg(point)[1]) == field_modulus

# *** Every element in an elliptic curve over a finite field can be generated by a generator ***
# When we are dealing with more than 2^200 points, we can verify the above by brute force. However, consider the
# fact that previously in `06_BN128_Addition`, we saw that `eq(multiply(G1, x), multiply(G1 x + curve_order))`
# is always true. This means we are able to generate up to `curve_order` points, then it cycles back to where
# it started.

# `optimized_bn128`
# Examining the library, you will see an implementation called optimized_bn128. If you benchmark the 
# execution time, you will see this version runs much quicker, and it is the implementation used by pyEvm. 
# For educational purposes however, it is preferable to use the non-optimized version as it structures the 
# points in a more intuitive way (the usual x, y tuple). The optimized version structures EC points as 
# 3-tuples, which are harder to interpret.
from py_ecc.optimized_bn128 import G1, multiply, neg, is_inf, Z1
print(G1)
# (1, 2, 1)