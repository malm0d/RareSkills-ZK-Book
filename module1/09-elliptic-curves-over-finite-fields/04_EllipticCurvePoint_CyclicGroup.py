# *** Cyclic Groups (refresher) ***
# A cyclic group is a group such that every element can be computed by starting with a generator element (G)
# and repeatedly applying the group’s binary operator. A very simple example is integers modulo 11 under addition.
# If your generator is 1, and you keep adding the generator to itself, you can generate every element in the group 
# from 0 to 10.
#
# Saying a elliptic curve points form a cyclic group (under elliptic curve addition) means we can represent every 
# number in a finite field as an elliptic curve point and add them together just like we would regular integers in
# a finite field. A finite field (also known as a Galois field) must have a number of elements that is a power 
# of a prime number
#
# That is 5 + 7 (mod p) is homomorphic to 5G + 7G. Where G is the generator of the elliptic curve cyclic group.
# This is only true of elliptic curves over finite fields that have a prime number of points, which are the kinds
# of curves we use in practice. This is something we’ll revisit later.
#
# ====================================================================================================
#
# *** Every elliptic curve point in a cyclic group has a “number”. ***
# A cyclic group, by definition, can be generated by repeatedly adding the generator to itself.
# Let’s use a real example of y^2 = x^3 + 3 (mod 11) with the generator point (G) being (4, 10).
# we can start with the point and generate every point in the group:
# for our purposes, (4, 10) is the generator point G
def double(x, y, a, p):
    lambd = (((3 * x**2) % p ) *  pow(2 * y, -1, p)) % p
    newx = (lambd**2 - 2 * x) % p
    newy = (-lambd * newx + lambd * x - y) % p
    return (newx, newy)

def add_points(xq, yq, xp, yp, p, a=0):
    if xq == yq == None:
        return xp, yp
    if xp == yp == None:
        return xq, yq

    assert (xq**3 + 3) % p == (yq ** 2) % p, "q not on curve"
    assert (xp**3 + 3) % p == (yp ** 2) % p, "p not on curve"

    if xq == xp and yq == yp:
        return double(xq, yq, a, p)
    elif xq == xp:
        return None, None

    lambd = ((yq - yp) * pow((xq - xp), -1, p) ) % p
    xr = (lambd**2 - xp - xq) % p
    yr = (lambd*(xp - xr) - yp) % p
    return xr, yr

next_x, next_y = 4, 10
print(0, 4, 10)
points = [(next_x, next_y)]
for i in range(1, 13):
    # repeatedly add G to the next point to generate all the elements
    next_x, next_y = add_points(next_x, next_y, 4, 10, 11)
    print(i, next_x, next_y)
    points.append((next_x, next_y))

# The output is (index, x, y):
# 0 4 10 #(This is G)
# 1 7 7
# 2 1 9
# 3 0 6
# 4 8 8
# 5 2 0
# 6 8 3
# 7 0 5
# 8 1 2
# 9 7 4
# 10 4 1
# 11 None None # point at infinity
# 12 4 10 # note that this is the same point as the first one

# Observe we have: (index + 1)G. Just like modular addition, when we “overflow”, the cycle starts over.
# Here, `None`` means the point at infinity, which is indeed part of the group. Remember: we
# define the set that makes up the elliptic curve as points on the elliptic curve AND the nowhere point.
# Adding the point at infinity to the generator returns the generator, as that is how the identity element
# is supposed to behave.
# We can assign each point a “number” based on how many times we added the generator to itself to arrive 
# at that point. We can use the following code to plot the curve and assign a number next to it:
import libnum
import matplotlib.pyplot as plt
def generate_points(mod):
    xs = []
    ys = []
    def y_squared(x):
        return (x**3 + 3) % mod

    for x in range(0, mod):
        if libnum.has_sqrtmod_prime_power(y_squared(x), mod, 1):
            square_roots = libnum.sqrtmod_prime_power(y_squared(x), mod, 1)

            # we might have two solutions
            for sr in square_roots:
                ys.append(sr)
                xs.append(x)
    return xs, ys

xs11, ys11 = generate_points(11)

fig, (ax1) = plt.subplots(1, 1);
fig.suptitle('y^2 = x^3 + 3 (mod 11)');
fig.set_size_inches(13, 6);

ax1.set_title("modulo 11")
ax1.scatter(xs11, ys11, marker='o');
ax1.set_xticks(range(0,11));
ax1.set_yticks(range(0,11));
ax1.grid()

for i in range(0, 11):
    plt.annotate(str(i+1), (points[i][0] + 0.1, points[i][1]), color="red")

plt.show()

# *** Point inverses are still vertically symmetric. ***
# From the plot, notice that points that share the same x-value add up to 12 (when we add their point numbers),
# which corresponds to the identity element (12 mod 12 = 0). If we add the point (4, 1) which is point 11 in 
# our plot to (4, 10) which is point 1, we will get the point at in infinity, which would be the 12th element 
# in the group.

# *** The Curve order is NOT the Field modulus. ***
# In this example, the order of the group is 12 (total number of elliptic curve points in our group), 
# despite the formula for the elliptic curve being modulo 11. This will be stressed several times, but we
# should NOT assume that the modulus in the elliptic curve is the group order. However, we can estimate the 
# curve’s order range from the field modulus itself using Hasse’s Theorem.
#
# *** If the number of points is prime, then the addition of points behaves like a finite field. ***
# In the plot above, there are 12 points (including 0). Addition modulo 12 is NOT a finite field because 
# 12 is not prime. 
# 
# A finite field (also known as a Galois field) must have a number of elements that is a power 
# of a prime number, i.e. p^n, where p is prime and n is a positive integer. The simplest case is when n = 1
# so the field has p elements, and the operations are addition and multiplication modulo p.
#
# If we only consider addition modulo 12, this is a finite abelian group, not a finite field.
# A field requires both addition and multiplication to satisfy certain properties (like distributivity, 
# and every non-zero element must have a multiplicative inverse). Since 12 is composite, not all non-zero elements
# in the group have multiplicative inverses (for example, 2 has no inverse -> see the plot above) so addition
# modulo 12 cannot be a finite field.
#
# However, if we pick our parameters for the curve carefully, we can create an elliptic curve where the points
# correspond to elements in a finite field. That is, the order of the curve equals the order of the finite field.
# For example, y^2 = x^3 + 7 (mod 43) creates a curve with 31 points total. 
#
# Since 43 is prime, we know that we have a finite field (mod 43), and addition and mulitplication wraps around 43, and
# every element has a multiplicative inverse.
# We also see that the Field modulus (43) is not equal to the Curve order (31) (and this is true by Hasse's theorem).
# The group, which is the 31 points defined by y^2 = x^3 + 7 (mod 43), forms a finite abelian group under elliptic
# curve addition; and since 31 is prime, the group is cyclic.
# This means that this group behaves like addition modulo 31 geometrically, using elliptic curve point addition.
#
# The intuition here is: in the finite field mod 43, we can perform operations such as addition and multiplication mod 43;
# and in the elliptic curve group (set of 31 points) we can perform elliptic curve point addition (which also covers
# elliptic curve point multiplication -> repeated addition).
#
# There is no direct homomorphism, but the discrete log problem presented by the elliptic curve group here, is more
# difficult than in the finite field alone. Importantly the large curve group (large prime subgroup) makes the discrete
# log problem difficult.
#
# When the order of the curve matches the order of the finite field every operation you do in the finite field 
# has a homomorphic equivalent in the elliptic curve. Such a curve is anomalous, and the discrete log can be 
# broken efficiently (avoid such curves).
#
# To go from a finite field to an elliptic curve, we we pick one point (arbitrarily) to be the generator, 
# then we multiply the element in the finite field by the generator.
