# Converting Algebraic Circuits to R1CS
https://www.rareskills.io/post/rank-1-constraint-system

## Prerequisites
- Arithmetic circuits
- Modular arithmetic
- All operations here happen in a finite field, so $-5$ is the additive inverse of $5 \ (\text{mod}\ p)$; and $2/3$ is the multiplicative inverse of $3 \ (\text{mod}\ p)$ times $2$.

## R1CS Overview
A Rank 1 Constraint System (R1CS) is an arithmetic circuit with the requirement that each equality constraint has one multiplication (and no restriction on the number of additions). 

That is, each constraint in an R1CS (each line in the system of equations) enforces exactly ONE multiplication between two linear combinations of variables (e.g. $x \cdot x$, or $x \cdot y$, etc), with no restrictions on the number of additions within those linear combinations or across the system of equations.

This makes the representation of the arithmetic circuit compatible with the use of bilinear pairings. The output of a bilinear pairing: $e: G_1 \bullet G_2 \rightarrow G_T$ cannot be paired again, as an element in $G_T$ cannot be used as part of the input of another bilinear pairing ($G_T$ is a multiplicative subgroup of a finte field, while $G_1$ and $G_2$ are elliptic curve groups). As such, we only allow one multiplication per constraint.

## The Witness Vector
In an arithmetic circuit, the witness is an assignment of values to all signals (variables) such that all constraints (equations) in the circuit are satisfied.

In an R1CS, the witness is a $1 \times n$ vector that contains the values of all input variables, output variables, and intermediate variables. It demonstrates that we have executed the circuit from start to finish, knowing all the input, output, and intermediate values.

By convention, the first element is always: $1$, 

This helps to make some calculations easier (more later).

For example, if we have the constraint:

$$
z = x^{2}y
$$

and we claim to know the solution for the constraint, then it means that we know: $x$, $y$, and $z$.

Because R1CS require exactly one multiplication per constraint, the above polynomial constraint above must broken down into simpler constraints, each with only ONE multiplication:

$$
v_1 = xx \\
z = v_1y
$$

A witness means that we don't just know $x$, $y$, and $z$, it also means we must also know every intermediate variable in the system of equations. Thus, our witness is the vector:

$$
[1, z, x, y, v_1]
$$

where each term has a value that satisfies the constraints above.

For example:

$$
[1, 18, 3, 2, 9]
$$

is a valid witness because when we pass the values into the circuit

$$
[constant = 1, \ z = 18, \ x = 3, \ y = 2, \ v_1 = 9]
$$

it satisfies the constraints

$$
\begin{align*}
v_1 = x \ast x \quad &\rightarrow \quad 9 = 3 \ast 3 \\
z = v_1 \ast y \quad &\rightarrow \quad 18 = 9 \ast 2
\end{align*}
$$

Note that the $1$ term in the witness vector is not used in this example, and it is a convenience that will be explained later on.

## Example 1: Transforming $z = xy$ into a R1CS
For this example, say we are proving: $4223 = 41 \times 103$.

Therrefore, the witness vector: $[1, z, x, y]$ will be assigned: $[1, 4223, 41, 103]$.

Before we can create an R1CS, the constraints need to be of the form:

$$
\text{result} = \text{LHS} \times \text{RHS}
$$

That is:

$$
\underbrace{z}_\text{result} = \underbrace{x}_\text{LHS} \times \underbrace{y}_\text{RHS}
$$

This is a trivial example. And as a reminder, to create a valid R1CS, we need a system of equations where each constraint has exactly ONE multiplication.


### System of Equations in the form: $\mathbf{O}\mathbf{a} = \mathbf{L}\mathbf{a}\circ\mathbf{R}\mathbf{a}$
The goal is to create a system of equations of the form:

$$
\mathbf{O}\mathbf{a} = \mathbf{L}\mathbf{a}\circ\mathbf{R}\mathbf{a}
$$

Where: $\mathbf{O}$, $\mathbf{L}$, and $\mathbf{R}$ are MATRICES of size: $n \times m$ (i.e. $n$ rows, and $m$ columns).

In the system of equations that make up the circuit:
- The vector $\mathbf{a}$ is the witness vector.
- Matrix $\mathbf{O}$ encodes all the result variables in the system of equations.
- Matrix $\mathbf{L}$ encodes all the LHS variables in the system of equations.
- Matrix $\mathbf{R}$ encodes all the RHS variables in the system of equations.

Importantly, matrices $\mathbf{O}$, $\mathbf{L}$, and $\mathbf{R}$ have the SAME NUMBER OF COLUMNS as the witness vector $\mathbf{a}$. And, each column (in both the matrices and the witness vector) represents the same variable the index is using.

Linking back to example 1, the witness has 4 elements: $[1, z, x, y]$, which means each of the matrices $\mathbf{O}$, $\mathbf{L}$, and $\mathbf{R}$ will have 4 columns (i.e. $m = 4$). And an index of $1$ for instance, would refer to the variable $z$ across the matrices and the witness vector.

The number of rows in each of the matrices $\mathbf{O}$, $\mathbf{L}$, and $\mathbf{R}$ will correspond to the number of constraints in the circuit (i.e. the number of equations in the system of equations) In example 1, as there is only one constraint: $z = xy$, then there will only be one row in each of the matrices (i.e. $n = 1$).

The R1CS for example 1 will be:

$$
z = xy
$$

$$
\mathbf{O}\mathbf{a} = \mathbf{L}\mathbf{a}\circ\mathbf{R}\mathbf{a}
$$

$$
\underbrace{\begin{bmatrix}
0 & 1 & 0 & 0 \\
\end{bmatrix}}_{\mathbf{O}}\mathbf{a} =
\underbrace{\begin{bmatrix}
0 & 0 & 1 & 0 \\
\end{bmatrix}}_{\mathbf{L}}\mathbf{a} \circ
\underbrace{\begin{bmatrix}
0 & 0 & 0 & 1 \\
\end{bmatrix}}_{\mathbf{R}}\mathbf{a}
$$

$$
\begin{bmatrix}0 & 1 & 0 & 0\end{bmatrix}
\begin{bmatrix}1 \\ 4223 \\ 41 \\ 103 \\ \end{bmatrix} =
\begin{bmatrix}0 & 0 & 1 & 0 \\ \end{bmatrix}
\begin{bmatrix}1 \\ 4223 \\ 41 \\103 \\ \end{bmatrix} \circ
\begin{bmatrix}0 & 0 & 0 & 1 \\ \end{bmatrix}
\begin{bmatrix}1 \\ 4223 \\ 41 \\ 103 \\ \end{bmatrix}
$$

Each item in matrices $\mathbf{O}$, $\mathbf{L}$, and $\mathbf{R}$ serves an an "indicator" for whether or not the variable that the column corresponds with is present. (Technically, it is the coefficient of the variable, but more on this in later examples).

Note that the multiplication between each matrix ($\mathbf{O}$, $\mathbf{L}$, $\mathbf{R}$) and the witness vector ($\mathbf{a}$) is a standard matrix multiplication operation. However, the operation: $\circ$ is a hadamard product (element-wise multipication).

The hadamard product between $\mathbf{La}$ and $\mathbf{Ra}$ enforces the one multiplication per constraint requirement in R1CS.

Given the witness $a$, the columns represent $[1, z, x, y]$, then:

- $ \mathbf{L}$ is $[0,0,1,0]$ because $x$ is present and it is the only variable on the LHS of the multiplication.

- $ \mathbf{R}$ is $[0,0,0,1]$ because $y$ is present and it is the only variable on the RHS of the multiplication.

- $ \mathbf{O}$ is $[0,1,0,0]$ because $z$ is the only variable in the "output" of the multiplication.

- There is no constant anywhere in the system of equations, and so the column for $1$ is zero in $\mathbf{O}$, $\mathbf{L}$, and $\mathbf{R}$ (more on when it is non-zero later).

We can verify that the equation is correct, in Python:
```python
import numpy as np

# Matrices: O, L, R
O = np.matrix([[0,1,0,0]])
L = np.matrix([[0,0,1,0]])
R = np.matrix([[0,0,0,1]])

# Witness vector: a
a = np.array([1, 4223, 41, 103])

# The multiplication `*` is element-wise (hadamard product),
# not the standard matrix multiplication. But `np.matmul` is
# the standard matrix multiplication operation.
#
# Result contains a bool indicating an element-wise indicator that
# the equality is true for that element. I.e. `==` compares each
# entry on the left to the corresponding entry on the right, and
# produces a boolean at the same position
result = np.matmul(O, a) == np.matmul(L, a) * np.matmul(R, a)

# Check that every element-wise equality is true.
# Collapses the boolean array to a single truth value,
# returning `True` only when very entry is `True`.
assert result.all(), "result contains an inequality"
```

It would be correct to say that we are just doing $41 \times 103 = 4223$ in a very verbose way. R1CS can be very verbose, but they map nicely to [Quadratic Arithmetic Programs (QAPs)](https://www.rareskills.io/post/quadratic-arithmetic-program), which can be made succint. QAPs are out of scope in this chapter.

However, this is an important point of R1CS. A R1CS communicates exactly the same information as the original arithmetic constraints, but with only ONE multiplication per equality constraint. In example 1, we only have one constraint, but we will add more in the next example.

## Example 2: Transforming $r = xyzu$ into a R1CS
This example shows how to deal with intermediate variables. If we consider the equation:

$$
r = xyzu
$$

This clearly has more than one multiplication operation in a single computation.

In an R1CS, each row of computation (each constraint) can only have ONE multipication, so the above equation needs to be broken up:

$$
\begin{align*}
v_1 &= xy \\
v_2 &= zu \\
r &= v_1v_2
\end{align*}
$$

Note that there is no fixed rule to say how we need to break up the original equation. The following is also valid:

$$
\begin{align*}
v_1 &= xy \\
v_2 &= v_1z \\
r &= v_2u
\end{align*}
$$

We will use the first transformation for this example.

### Size of $\mathbf{O}$, $\mathbf{L}$, and $\mathbf{R}$
Remember what was said about the witness vector $a$ and number of columns and rows in matrices $\mathbf{O}$, $\mathbf{L}$, and $\mathbf{R}$.

Since we are dealing with $7$ variables in the system of equations: ($r$, $x$, $y$, $z$, $u$, $v_1$, $v_2$), the witness vector will have $8$ elements (the first being the additional constant $1$); and each of the matrices will have $8$ columns.

Since we now have $3$ constraints in the R1CS, then each of the matrices will have $3$ rows.

### Left Hand Terms (LHS) and Right Hand Terms (RHS)
